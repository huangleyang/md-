目标
js就是先执行主线程任务在等主线程空闲时 执行事件队列 中的函数
(将函数放入主线程队列中)只有在主线程的才会执行 当函数满足条件的时候放入主线程队列中

掌握javascript面向对象开发相关模式

掌握在javascript中使用正则表达式

javascript 是一个编程语言
是一门弱类型语言
是一门解释型语言
是一门脚本类型的语言
是一门面向对象的语言
是一门动态型语言


服务器 ：一台计算机，一台配置比较高的电脑，提供服务；提供服务的团建，硬件html页面

js特点
1 . 解释执行  解释一行执行一行 慢
 java c# 编译语言 一次性把代码编译成可执行的代码，然后在一行一行的执行 快
2.灵活动态特性 可以随意给对象添加属性和方法
3. 头等函数   函数在javascript一等公民
4 执行环境   宿主环境



用户在浏览器中输入域名（一个域名对应着ip地址）搜索后 由DNS 服务器返回一个ip地址给你 你在向服务器请求 服务器在向浏览器返回所需要的数据

User interface 用户页面

Browser engine 浏览器引擎

Rendering engine  渲染引擎 解析ccs html 生成dom树 实时更新

javascript interpreter  执行js代码

networking   接受和发送请求

ul backend 和操作系统进行交互；

1 .对象是一个单个事物的抽象
2 .对象是一个容器 ，封装了属性（proprety）和方法 （method）


面向对象的特性
封装性
继承性
[多态性]抽象


面向对象的方式

创建对象 调用对象的属性和方法
创建一个模板， 用于创建对象
在javaScript中创建对象的模板是构造函数


构造函数 构造函数第一个字母大写
function Element(name,score){
this.name =  name;
this.score = score;
}
构造函数 -- 构造对象的函数
    function Hero(name, blood, weapon) {
      this.name = name;
      this.blood = blood;
      this.weapon = weapon;

      this.attack = function () {
        console.log(this.weapon + ' 攻击敌人');
      }
    } 

1.会在内从中创建一个空对象
2.设置构造函数的this，让this指向刚刚创建好的对象
3.执行构造函数的代码
4.返回对象
构造函数可以new一个新的变量让其变为一个对象的方式接受构造函数（变量名构造函数一样区分大小写）
    var hero = new Hero('刘备', 100, '剑');
hero.attack();


常见对象四种方式
创建空对象
var obj =new Object()
obj.name = 100;

创建字面量
var obj = {
name:"刘备"
}
工厂函数（使用函数来创建对象）
function 函数名(name,xixi){
var obj = new Object()
obj.name =name;
obj.xixi = xixi;
return obj
}
获取对象的具体类型
instanceof  可以获取 建议使用
语法console.log(对象名 instanceof 构造函数名 )
obj是变量名 Obj是构造函数名
对象名.constructor  不建议
其中typeof 不能获取具体类型


构造函数 
实例化对象的时候（new给新对象名的时候） 构造函数会被执行
this 指向谁（对象名） 谁实例化了这个构造函数 就只向谁
实例成员//对象成员


function Hero(name, blood, weapon) {
      // 实例成员  /  对象成员   --  跟对象相关的成员，将来使用对象的方式来调用
      this.name = name;
      this.blood = blood;
      this.weapon = weapon;

      this.attack = function () {
        console.log(this.weapon + ' 攻击敌人');
      }
    } 

    // 静态成员  -- 直接给构造函数添加的成员
    Hero.version = '1.0';
    

    var hero = new Hero('刘备', 100, '剑');
    hero.attack();

    var hero1 = new Hero('关羽', 100, '刀');
    hero1.attack();
    // 静态成员不能使用对象的方式来调用
    console.log(hero.version);

    // 静态成员使用构造函数来调用
    console.log(Hero.version);
静态成员
构造函数中新添加的 不能用对象的方式来调用 只能用构造函数来调用


每一个构造函数都有一个属性 原型/原型对象
prototype 原型
语法：构造函数名.prototype.方法名 = function(){}
在构造函数外面创建方法是为了节省创建多个对象的储存
prototype为了解决 创建函数过多方法名重复所以使用原型

当调用对象的属性或者方法的时候，先去找对象本身的属性/方法
如果对象没有属性/方法，此时去调用原型中的属性/方法

s1.__proto__对象的__proto__等于 构造函数的student.prototype
__proto__属性是非标准属性 
constructor 构造函数
constructor 作用记录了创建该对象的构造函数 记录了创建该对象的构造函数
为什么要有__proto__因为我们要引用原型里面的数据所以有一个__proto__来显示原型里面的数据


读取属性 现在对本身查找text属性，如果没有的话，回去原型上找
所有的对象都要toString（）
在对象的原型对象中的原型对象中 
设置属性s1.name = "xxx"
 test舒心在原型对象上，而在设置属相的时候，不会搜索原型链
而是直接对象新增一个text属性


当我们改变构造函数的prototype是需要重新设置constructor（不然就在原型对象中找不到constructor所指向的构造函数）
语法：constructor:构造函数名
先去设置原型属性，再去创建对象，才可以访问原型对象中的成员



数组或者String中的prototype是不可以修改的
（如果能修改会去掉自身携带的一些方法）所以系统自定义prototype是不可以修改的
但是可以新增一个方法
Array.prototype.函数名=function(){} 可以用新增的方法以后的数组中都有这个方法


当实例化对象的时候 对象中有函数中的原型对象
面向对象的特性 封装 继承 多态
对象：具体特指的某个事物 ，有特性（属性） 和行为（方法）


如何创建对象
通过调用new Object ， 还有{}  ，自定义构造函数


原型指向可以改变
实例对象的原型__proto__指向的该对象所在的构造函数的原型对象
构造函数的原型对象指向如果改变了，实例对象的原型(__proto__)指向也会改变


如果原型指向改变了，那么就应该在原形指向改变之后添加原型方法


因为JS是一门动态类型的语言，对象没有什么，只是点了，那么这个对象就有了这个东西，没有这个属性，只要有对象.属性名字，对象就有了这个属性了，但是该属性没有赋值，所有是undefined


拷贝是添加对象  只是单纯的添加对象 是对象与对象之间的关系
继承是类型和类型之间的关系
继承目的 把子类型公共的成员提取到父类型中，代码重用


原型继承无法传参数
而且设置继承原型时必须设置constructor为之前的子类型构造函数不然他指向父类型的构造函数 


bing()改变函数的this，并返回一个新的函数 （不调用函数）
bing方法要调用需要 重新调用 bing()();
bing()方法中第一个值是this指向
语法fn.bing(指向，ele，ele)


在call方法中第一个值是this指向 （直接调用不需要再调用）
现在浏览器 不会提升if语句中的函数声明（yu解析）
在IE的老版本，if语句的函数声明会提升



五种函数
1.普通函数的调用时window
function fn(){ }

2.方法调用 this调用该方法的对象
var obj = {
fn:function (){}}

3.构造函数调用 this指向该构造函数的对象

4.作为事件的处理函数 触发事件的对象

5.定时器的参数 this指向window （定时器中有一个函数）
函数的this，是由函数调用的时候来确定指向的
谁调用this就指向谁 如果是一个普通的变量 指向的是window


改变this指向的三种方法 call bind apply
函数是个对象 有事属性和方法

call
1.调用函数，改变函数中的this
2,。第一个参数 设置函数内部this的指向
其他参数 对应函数的参数
3.函数的返回值 call的返回值就是函数的返回值


apply
1.调用函数，改变函数中的this
2,。第一个参数 设置函数内部this的指向
其他参数 是数组方式
3.函数的返回值 call的返回值就是函数的返回值

添加伪数组是不能直接写 obj.4 =30 属性值 要写obj.["4"] = 属性值将4作为变量来使用（麻烦）
可以直接用数组的原型属性来改变伪数组的属性
语法：Array.prototype.push.call(obj,30)
Array.prototype.push 这都是在寻找call


fn.arguments 伪数组 获取到的范数的实参
fn.caller 函数的调用者 在全局范围调用的时候caller 是null
fn.name 函数的名称 字符串类型
fn.length 函数的形参个数

当函数的参数个数不固定的时候
在函数内部可以通过argumengts获取到实际传过来的参数
这里arguments 

高阶函数
1.函数作为参数
2.函数作为返回值时


闭包，在一个作用域访问到另一个作用域的变量
闭包的特点 本来当一个函数结束之后会自动销毁 但还有函数要调用这个函数里面的变量所以就没有销毁 延展了函数作用域的范围


函数也是对象 所以函数也有属性和方法

闭包 
先执行 执行栈（执行队列）script里面的代码
等执行栈中的执行完毕再执行任务队列（待执行） 事件处理函数 
等待执行的事件处理函数触发时 会被放入执行队列中 （执行）
任务队列中的不会被执行 只有当被放入执行队列中才会被执行


闭包发生的场景【重点】
函数嵌套函数
内部函数使用了外部函数中的变量
内部函数是外部函数的返回值

闭包的作用 读取函数内部的变量

递归：自己调用自己 
在调用的过程中会出错 一直自调用
会内存溢出：超过了最大的堆栈大小
所以递归一般都要写一个结束的条件 


浅拷贝 -只拷贝第一层属性
拷贝简单类型 拷贝后改变被拷贝的属性 拷贝的属性不变
但是拷贝复杂数据类型时拷贝的是复杂类型的地址而不是创建新的区域
所以改变被拷贝的复杂数据类型中的属性时，拷贝的也会变
 因为拷贝记录被拷贝复杂数据类型的地址


正则表达式
\d 查找所有的数字/0-9之间的单个数字
[a-z] 查找所有的字母
<.+>所有的标签和里面内容
<.+?> 所有标签没有内容
\D 查找所有非数字
\w 字母 数字和下划线
\W 去反 换行 符号 文字
\s 换行 空格
\. 单个字符 匹配不带空格换行
^尖括号 以什么开头
$ 以什么结尾

限字符
*匹配0个和多个
+最少要匹配到一个
？匹配找到0个或者一个的
{n}重复n多少次
语法\d{6} 匹配6个数字的
{n，}重复n多次 或者更多次
{n,m}重复n到m次
获取邮编（6位数字）
^\d{6}$
[]字符串中括号括起来，表示匹配其中的任一字符，相当于或的意思
[^] 匹配除中括号以内的内容
\转义符
|或者 或前 或后 一般和小括号搭配使用 
[\u4e00-\u9fa5] 匹配中文
g:global 的缩写 代表全局匹配
i ignore的缩写 区分大小写

正则表达式
1.给定的字符串是否符合正则表达式过滤逻辑（匹配）
2.可以通过正则表达式，从字符串中获取我们想要的的特定部分（提取）
3.强大的字符替换能力（替换）


内置对象 RegExp
语法：var regularExpression = new RegExp() 使用\时要写\\

第二种写法 var reg = \\
括号里面可以有两个参数 第一个参数 模式pattern
第二个参数 flag i忽略大小写 g全局匹配

onchange 事件 当文本改变并且失去焦点的时候
onkeydown 键盘弹起时（牛逼）
onblur失去焦点

跟正则表达式相关的方法
1RegExp 对象
test()匹配
exec() 提取 只返回一个匹配到的结果 如果没有匹配到返回null
如果要提取多个要用do（）while{}循环（声明正则时害的加上全局匹配）


2.String对象
match() 提取多个结果
语法 提取对象.match(reg) 
replace() 替换
语法：切割对replace(reg,替换为) reg不逊啊哟家引号
split() 切割
语法：切割对象.split(reg) []中不需要转义
search() 返回符合指定模式的子串在字符串中首次出现的位置，失败返回-1 只返回一个值
语法 被查找的对象.search(reg)
trim()去除前后的空白

【重点】
去除空格
str.split(" ".join(""))

获得小括号里面的内容 RegExp.$1 这是一个属性 获取第一个小括号里面的内容

贪婪模式 当找到第一个匹配时不返回还会往后查找找到第二个符合匹配时会把从第一个到第二个匹配到的全部输出<.+>
非贪婪模式<.+?> 匹配到第一个符合时返回 在往后找